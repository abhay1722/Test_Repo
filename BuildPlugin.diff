diff --git a/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy
index ad06e19d266..61584a58784 100644
--- a/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy
+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy
@@ -1021,33 +1021,81 @@ class BuildPlugin implements Plugin<Project> {
             String currentID = ""
             project.file("/proc/cpuinfo").readLines().forEach({ line ->
                 if (line.contains(":")) {
-                    List<String> parts = line.split(":", 2).collect({it.trim()})
-                    String name = parts[0], value = parts[1]
-                    // the ID of the CPU socket
-                    if (name == "physical id") {
-                        currentID = value
-                    }
-                    // Number  of cores not including hyper-threading
-                    if (name == "cpu cores") {
-                        assert currentID.isEmpty() == false
-                        socketToCore[currentID] = Integer.valueOf(value)
-                        currentID = ""
-                    }
-                }
-            })
-            return socketToCore.values().sum()
-        } else if ('Mac OS X'.equals(System.getProperty('os.name'))) {
-            // Ask macOS to count physical CPUs for us
-            ByteArrayOutputStream stdout = new ByteArrayOutputStream()
-            project.exec {
-                executable 'sysctl'
-                args '-n', 'hw.physicalcpu'
-                standardOutput = stdout
+					List < String > parts = line.split(":", 2).collect({
+						it.trim()
+					})
+					String name = parts[0], value = parts[1]
+					//check for s390x arch
+					if (name == "vendor_id") {
+						if (value == "IBM/S390") {
+							currentID = value
+							socketToCore[currentID] = findDefaultParallel_s390x()
+						}
+					}
+					// the ID of the CPU socket
+					if (name == "physical id") {
+						currentID = value
+					}
+					// Number  of cores not including hyper-threading
+					if (name == "cpu cores") {
+						assert currentID.isEmpty() == false
+						socketToCore[currentID] = Integer.valueOf(value)
+						currentID = ""
+					}
             }
-            return Integer.parseInt(stdout.toString('UTF-8').trim())
-        }
-        return Runtime.getRuntime().availableProcessors() / 2
-    }
+        })
+        return socketToCore.values().sum()
+		} else if ('Mac OS X'.equals(System.getProperty('os.name'))) {
+			// Ask macOS to count physical CPUs for us
+			ByteArrayOutputStream stdout = new ByteArrayOutputStream()
+			project.exec {
+				executable 'sysctl'
+				args '-n', 'hw.physicalcpu'
+				standardOutput = stdout
+			}
+			return Integer.parseInt(stdout.toString('UTF-8').trim())
+		}
+		return Runtime.getRuntime().availableProcessors() / 2
+	}
+
+
+	//calculate no. of physical cpu cores on s390x
+	private static int findDefaultParallel_s390x() {
+		String s = null;
+		int processors = 0;
+		// code to count the  number of Physical cores for s390x
+		try {
+
+			// run the Unix "lscpu" command
+			// using the Runtime exec method:
+			Process p = Runtime.getRuntime().exec("lscpu");
+
+			BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
+			BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));
+			// read the output from the command
+			while ((s = stdInput.readLine()) != null) {
+				if (s.contains(":")) {
+					String[] strings = s.split(":");
+					String name = strings[0], value = strings[1];
+					if (name.equals("CPU(s)")) {
+						processors = Integer.valueOf(value.trim()).intValue();
+					}
+				}
+			}
+
+			return processors;
+
+			// read any errors from the attempted command
+			while ((s = stdError.readLine()) != null) {
+				System.out.println(s);
+			}
+
+			System.exit(0);
+		} catch (IOException e) {
+			e.printStackTrace();
+			System.exit(-1);
+		}
+	}
 
     private static configurePrecommit(Project project) {
         Task precommit = PrecommitTasks.create(project, true)
